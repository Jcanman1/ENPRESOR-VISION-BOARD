import os, subprocess, pathlib, re, uuid
from openai import OpenAI

# Pull the plain-English request from the comment text (e.g., "/gpt5 do X")
raw = os.getenv("TRIGGER_TEXT", "").strip()
m = re.search(r"/gpt5\s*(.*)", raw, re.I | re.S)
user_request = (m.group(1) if m and m.group(1) else raw or "Small cleanup and docstrings").strip()

repo = pathlib.Path(".").resolve()
client = OpenAI(api_key=os.environ["OPENAI_API_KEY"])

SYSTEM = """You are an expert software engineer.
Return ONLY a valid unified diff (git apply -p0 compatible) implementing the request.
Rules:
- No prose, no code fences, no markdown.
- Use paths relative to the repo root.
- Keep changes minimal and buildable.
- To add new files, include proper diff headers.
"""

# Keep prompt small: list tracked files and include truncated contents
files = subprocess.check_output(["git", "ls-files"], text=True).splitlines()
snapshot_parts = []
for f in files[:500]:  # cap to keep context reasonable
    try:
        txt = pathlib.Path(f).read_text(encoding="utf-8", errors="ignore")
        if len(txt) > 20000:  # truncate huge files
            txt = txt[:15000] + "\n/* …truncated… */\n"
        snapshot_parts.append(f"\n===FILE:{f}===\n{txt}")
    except Exception:
        pass

instruction = f"Request: {user_request}\n\nRepository snapshot (partial):\n{''.join(snapshot_parts)}"

# --- Call OpenAI Responses API ---
resp = client.responses.create(
    model="gpt-5",  # use your exact GPT-5 model name
    instructions=SYSTEM,
    input=instruction
)

patch = resp.output_text or ""
patch = patch.strip()

# Save raw outputs for debugging
debug_txt = repo / ".gpt5_debug.txt"
debug_txt.write_text(
    f"=== USER REQUEST ===\n{user_request}\n\n"
    f"=== PATCH (first 5k chars) ===\n{patch[:5000]}\n\n"
    f"=== PATCH LENGTH === {len(patch)} chars\n",
    encoding="utf-8"
)

# Log to GitHub step output too (truncated so logs stay readable)
print("\n---- GPT-5 produced unified diff (first 400 lines) ----")
for i, line in enumerate(patch.splitlines()):
    if i >= 400:
        print("... [truncated]")
        break
    print(line)
print("---- end preview ----\n")

# Basic sanity check: must look like a unified diff
if not any(
    line.startswith(("diff --git ", "--- ", "+++ ", "@@ "))
    for line in patch.splitlines()[:20]
):
    # Write the entire body to artifact and fail early
    (repo / ".gpt5.patch").write_text(patch, encoding="utf-8")
    print("ERROR: GPT-5 did not return a valid unified diff. See .gpt5.patch and .gpt5_debug.txt artifacts.")
    raise SystemExit(2)

# Write patch to disk
(repo / ".gpt5.patch").write_text(patch, encoding="utf-8")

# --- Create a working branch ---
branch = f"gpt5/{uuid.uuid4().hex[:8]}"
subprocess.check_call(["git", "checkout", "-b", branch])

# --- Apply patch ---
try:
    subprocess.check_call(["git", "apply", "--whitespace=fix", str(repo / ".gpt5.patch")])
except subprocess.CalledProcessError as e:
    print("ERROR: Failed to apply patch. Leaving .gpt5.patch and .gpt5_debug.txt for inspection.")
    raise

# --- Commit ---
subprocess.check_call(["git", "add", "-A"])
title = f"GPT-5: {user_request[:60]}"
subprocess.check_call(["git", "commit", "-m", title])

# --- Persist branch/PR meta ---
(repo / ".gpt5_branch").write_text(branch, encoding="utf-8")
(repo / ".gpt5_title").write_text(title + "\n\nAutomated PR generated by GPT-5.", encoding="utf-8")

# --- Also write a short step summary (nice to have) ---
summary = repo / os.environ.get("GITHUB_STEP_SUMMARY", "GITHUB_STEP_SUMMARY_NOT_SET")
try:
    with open(os.environ["GITHUB_STEP_SUMMARY"], "a", encoding="utf-8") as fh:
        fh.write(f"### GPT-5 request\n```\n{user_request}\n```\n")
        fh.write("### Patch preview (first 50 lines)\n```\n")
        for i, line in enumerate(patch.splitlines()[:50]):
            fh.write(line + "\n")
        fh.write("```\n")
except KeyError:
    pass  # not running inside Actions or var not present
